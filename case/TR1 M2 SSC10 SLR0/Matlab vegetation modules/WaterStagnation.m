%% To guarantee the tree life when water stagnation 2020-09-02
%>> 1) find ponding area where elevation <= 2 side cells before and after and meanwhile the RP > 0.5, mark as Cell WS
%>> 2) find upper-intertidal flat profile where elevation difference <= 0.5 cm && Inundation stress < 0.5 && 
%      mortality mark == 4 && RP>=RP_last year>0, mark as cell WS  
%>> 3) Protect vegetation in Cell WS
%>> 4) Release ponding when no longer ponding or RP<0.5 or below MWL 
%>> 4) Release flattern cell when no longer flat or RP<0.5 or below MWL


if Veg_WStag == 1 &&  year > year_ini+1 && ets == 1 && ~isempty(trv_trd)
    % 1. initialize
    if year == year_ini+2
       cell_ws_pro_veg    = zeros(Ndim,Mdim);  % a long-stay cell to store ponding cell 
       cell_fl_pro_veg_RP = zeros(Ndim,Mdim);  % a long-stay cell to store flattern cell  
    end
   
    % 2. evaluate new water stagnation in ponding area
    %>>1) New lower elevation cell (ponding area)
    [~,position_mwl] = min(abs(-ElePro(2,2:end-1)-MWL)); % find x_mwl location
    EleDiff          = ones(1,Mdim-2);
    EleDiff(1,2:end) = diff(-ElePro(Ndim-1,2:end-1)); % ele_current-ele_before
    EleDiff_sign     = sign(EleDiff); % sign of ele. diff.
    Ele_ws           = find(EleDiff_sign<=0); % cell No. stay high and the cell behind remains low or equal
    cell_ws_pro      = zeros(Ndim,Mdim); % store protection cell based on profile
    if ~isempty(Ele_ws)
        for i = 1:numel(Ele_ws)
            [~,position_ws] = min(abs(-ElePro(2,Ele_ws(i)+1:end)--ElePro(2,Ele_ws(i)))); % find the location with similar elevation
            cell_ws_pro(Ndim-1,Ele_ws(i):Ele_ws(i)+position_ws) = 1;
            cell_ws_pro(Ndim-1,1:position_mwl+1) = 0; % excluding cells below MWL
        end
    end
    clear EleDiff_sign Ele_ws i position_ws
    %>>2) New higher inundation regime
    P_ws            = mean(cat(3, d3dparameters.Flood(year-1).PerYear{:,1}),3); % find last annual average inundation regime
    veg_xmin        = min(trv_trd(:,2));% find the most seaward cell No
    cell_ws_veg     = zeros(Ndim,Mdim); % store protection cell based on vegetation
    Veg_abnor       = find(P_ws(Ndim-1,veg_xmin+1:end) > 0.5); % in abnormal flooding period
    if ~isempty(Veg_abnor)
        cell_ws_veg(Ndim-1,veg_xmin+Veg_abnor) = 1;
    end
    clear Veg_abnor
    %>>3) release cells that are no longer ponding and RP < 0.5
    Pond_veg = find(cell_ws_pro_veg > 0); % find previous protected veg due to ponding & higher RP
    if ~isempty(Pond_veg)
        for i = 1:numel(Pond_veg)
            [~,col_wv] = ind2sub(size(cell_ws_pro_veg),Pond_veg(i));
            if cell_ws_pro(Pond_veg(i)) == 0 || col_wv < position_mwl+1 || P_ws(Pond_veg(i)) < 0.5
                cell_ws_pro_veg(Pond_veg(i)) = 0; % stop protecting cells no longer ponding and reasonable RP or below MWL with higher RP
            end
            clear col_wv
        end
    end
    clear Pond_veg i ElePro MWL
    %>>4) Update: low profile + long vegetation inundation
    cell_ws_pro_veg = cell_ws_pro_veg + cell_ws_pro.*cell_ws_veg;
    clear cell_ws_pro cell_ws_veg
    
    % 3. evaluate potential water stagnation area in flat profile
    %>>1) find upper-intertidal flat profile
    Ele_flat         = find(EleDiff(1,position_mwl+1:end) < 0.5/100); % define flat area as ele. diff. < 0.5 cm
    cell_fl_pro      = zeros(Ndim,Mdim); % store protection cell based on flat profile
    if ~isempty(Ele_flat)
        cell_fl_pro(Ndim-1,position_mwl+Ele_flat+1) = 1;
        cell_fl_pro(Ndim-1,1:position_mwl+1)        = 0; % excluding cells below MWL 
    end
    clear Ele_flat EleDiff
    %>>2) find inundation stress < 0.5 && mortality mark == 4
    Veg_flat        = trv_trd((trv_trd(:,14)<0.5 & trv_trd(:,19)==4),2);
    cell_fl_veg     = zeros(Ndim,Mdim); % store protection cell based on dying veg
    if ~isempty(Veg_flat)
        cell_fl_veg(Ndim-1,Veg_flat) = 1;
    end
    clear Veg_flat
    %>>3) find cells with increasing inundation regime
    P_ws_pre        = mean(cat(3, d3dparameters.Flood(year-2).PerYear{:,1}),3); % find last annual average inundation regime
    RP_flat         = find(P_ws(Ndim-1,veg_xmin+1:end) >= P_ws_pre(Ndim-1,veg_xmin+1:end) & P_ws_pre(Ndim-1,veg_xmin+1:end) > 0); % find increasing RP in wet cell
    cell_fl_RP      = zeros(Ndim,Mdim); % store protection cell based on increasing RP
    if ~isempty(RP_flat)
        cell_fl_RP(Ndim-1,veg_xmin+RP_flat) = 1;
    end
    clear P_ws_pre veg_xmin RP_flat
    %>>4) Release 1.cells that below MWL and 2.cells that are no longer flattern 3. reasonable RP
    flat_veg = find(cell_fl_pro_veg_RP > 0);
    if ~isempty(flat_veg)
        for i = 1:numel(flat_veg)
            [~,col_fv] = ind2sub(size(cell_fl_pro_veg_RP),flat_veg(i));
            if col_fv < position_mwl+1 || cell_fl_pro(flat_veg(i)) == 0 || P_ws(flat_veg(i)) < 0.5
                cell_fl_pro_veg_RP(flat_veg(i)) = 0; % stop protecting cells below MWL & not flattern cells with higher RP
            end
            clear col_fv
        end
    end
    clear flat_veg position_mwl P_ws i
    %>>5) Update: flat profile+dying veg+increasing RP
    cell_fl_pro_veg_RP = cell_fl_pro_veg_RP + cell_fl_pro.*cell_fl_veg.*cell_fl_RP;
    %>>5) update cell where vegegtation need to be protected
    cell_ws = cell_ws_pro_veg + cell_fl_pro_veg_RP;
    clear cell_fl_pro cell_fl_veg cell_fl_RP
    
    % 4. water stagnation cells exist
    if sum(sum(cell_ws))>0 % stagnation cell with veg or without veg?
        ws_loc          = find(cell_ws > 0);
        [row_ws,col_ws] = ind2sub(size(cell_ws),ws_loc);
        for ws_m = 1:length(ws_loc)
            ws_mark = find(trv_trd(:,1) == row_ws(ws_m) & trv_trd(:,2) == col_ws(ws_m)); % find if stagnation in trv_trd
            if ~isempty(ws_mark) % stagnation has veg
                trv_trd(ws_mark,[14 18 19]) = 0; % set I, I*C and mortality mark to 0 to keep it alive but stop growing
            end
            clear ws_mark
        end
        clear ws_loc ws_m row_ws col_ws cell_ws
    end
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
end